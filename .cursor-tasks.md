# Who You Know (WYK) Project – Comprehensive Task Checklist

## 1. User Authentication & Profiles

### 1.1 Registration & Login Flows
- [ ] **1.1.1**: Set up the user authentication module and database connection (create base project structure, install necessary auth libraries, configure database).
- [ ] **1.1.2**: Define the User model/schema in the database with fields for unique email, hashed password, name, user role (job-seeker or recruiter), etc.
- [ ] **1.1.3**: Implement secure password hashing (e.g. bcrypt) for storing user passwords and verify hashing works for login verification.
- [ ] **1.1.4**: Create a backend API endpoint for **User Registration** that accepts name, email, password (and role if applicable); validate input (strong password, email format, unique email) and create a new user record.
- [ ] **1.1.5**: Send a verification email upon registration (generate a unique token, email it via an email service) to confirm the user's email address.
- [ ] **1.1.6**: Create an API endpoint for **Email Verification** that verifies the token and activates the user account (setting an "emailVerified" flag).
- [ ] **1.1.7**: Create a backend API endpoint for **User Login** that checks credentials (email/password), verifies email is confirmed, and on success generates an authentication token or session.
- [ ] **1.1.8**: Implement session management or JWT token generation for authenticated sessions (configure token expiry, signing secret, and secure cookie storage if using cookies).
- [ ] **1.1.9**: Implement a **Logout** endpoint or front-end action that invalidates the session or removes JWT token (e.g. delete token cookie or local storage entry).
- [ ] **1.1.10**: Implement **Forgot Password** flow – create an endpoint to request password reset (generate reset token, email it to user) and an endpoint to reset password using the token (validate token, allow new password set).
- [ ] **1.1.11**: Develop the front-end **Registration Page** with a form for name, email, password (and role selection if needed); include client-side validation for required fields and password policy.
- [ ] **1.1.12**: Integrate the registration form with the backend API (submit form, handle success by prompting email verification, handle error messages like "email already in use").
- [ ] **1.1.13**: Develop the front-end **Login Page** with form inputs for email and password, including validation (e.g. not empty).
- [ ] **1.1.14**: Integrate the login form with the login API (on success, store auth token or session info in browser storage/cookies, redirect to user dashboard; on failure, show error).
- [ ] **1.1.15**: Ensure the front-end detects and handles the email-not-verified case (e.g. prompt user to verify if login fails due to unverified email).
- [ ] **1.1.16**: Write unit tests for registration logic (valid vs invalid inputs, duplicate email handling) and login logic (correct credentials vs incorrect, token generation).
- [ ] **1.1.17**: Write integration tests for the full registration and login API flow, including email verification and password reset (simulate the end-to-end API calls and database updates).
- [ ] **1.1.18**: Implement security best practices for auth flows (rate-limit login attempts, require strong passwords, secure token storage, and enforce HTTPS in production).

### 1.2 Profile Creation & Management
- [ ] **1.2.1**: Extend the User model or create a Profile model to include additional profile fields (e.g. bio, location, job title, years of experience, skills, education, profile photo URL).
- [ ] **1.2.2**: Create a backend API endpoint for **Profile Fetch** that returns the logged-in user's profile details (combine user basic info and extended profile fields).
- [ ] **1.2.3**: Create a backend API endpoint for **Profile Update** allowing users to update profile fields (name, bio, location, etc.). Include validation (e.g. proper data types, length limits).
- [ ] **1.2.4**: Implement server-side handling for **Profile Photo Upload** (endpoint to upload a profile image file, store the file, update user's profile with the image path).
- [ ] **1.2.5**: Develop the front-end **Profile Page** where users can view their profile information (personal details, uploaded CV status, etc.).
- [ ] **1.2.6**: Develop the front-end **Edit Profile Form** (could be on the profile page or a separate page/modal) to allow users to input or change their profile information and upload a profile picture.
- [ ] **1.2.7**: Integrate the Edit Profile form with the Profile Update API (send updated fields, handle success by refreshing profile view, handle validation errors).
- [ ] **1.2.8**: Ensure the profile page displays the profile photo or a default avatar, and that updating the photo immediately reflects in the UI.
- [ ] **1.2.9**: Implement front-end and backend checks to ensure only the authenticated user can edit their own profile (authorization rules).
- [ ] **1.2.10**: If there are profile privacy settings (e.g. toggle to hide profile from recruiters), implement fields and UI controls for those settings and enforce them in relevant queries (for candidate search).
- [ ] **1.2.11**: Write unit tests for profile update logic (e.g. cannot set invalid values, proper saving of each field, security of file upload).
- [ ] **1.2.12**: Write integration tests for profile API (fetch and update endpoints with authentication, verifying the data changes persist correctly).
- [ ] **1.2.13**: Ensure that profile data is properly linked with other features (for example, updated skills in profile should influence job matching algorithm results).

### 1.3 Company/Recruiter Profile Features
- [ ] **1.3.1**: Extend the User model with a recruiter flag or role, and create a **Company** model (fields: company name, description, website, logo, industry, etc.) to represent recruiter organizations.
- [ ] **1.3.2**: Create a backend API endpoint for **Company Profile Creation** allowing a recruiter user to create and link a company profile (or join an existing company, if multiple recruiters per company).
- [ ] **1.3.3**: Create a backend API endpoint for **Company Profile Update** so recruiters can edit company information (with validation on fields like valid URL for website).
- [ ] **1.3.4**: Associate recruiter-type users with a Company record (one-to-many relationship: company can have multiple recruiter users). Enforce that only recruiter users can create/edit company profiles.
- [ ] **1.3.5**: Develop the front-end **Company Profile Page** for recruiters to input company details or view their company info. Include a form for company name, logo upload, description, etc.
- [ ] **1.3.6**: Integrate the Company Profile form with the backend (allow create on first setup, and subsequent edits; handle showing success or error messages).
- [ ] **1.3.7**: Allow a recruiter to upload a **Company Logo** image in the company profile form (set up file upload handling similar to profile photo).
- [ ] **1.3.8**: Implement front-end display of company profile info on relevant screens – for example, when a recruiter sends a contact request, the candidate can see the company name and details.
- [ ] **1.3.9**: If multiple recruiters can belong to one company, implement an **Invite Recruiter** feature: allow an existing recruiter to invite another (via email) to join their company profile. (One-story-point task: send invite email with link to registration associating with that company).
- [ ] **1.3.10**: Ensure that recruiters can switch context between personal profile and company profile easily on the UI (if needed, e.g. a toggle or separate sections).
- [ ] **1.3.11**: Implement authorization checks so that only recruiters belonging to a company can edit that company's profile (and non-recruiter users cannot access these endpoints at all).
- [ ] **1.3.12**: Write tests for company profile creation and updates, including edge cases (duplicate company names, unauthorized access, etc.).
- [ ] **1.3.13**: (Optional) If a recruiter user can have a public-facing profile (for candidates to view some recruiter info), implement a limited recruiter profile view (e.g. name, company, contact info if public).

## 2. CV Management

### 2.1 Uploading & Processing CVs
- [ ] **2.1.1**: Set up storage for CV files (decide on local storage or cloud service for file uploads, configure access credentials if needed).
- [ ] **2.1.2**: Create a backend API endpoint for **CV Upload** that allows a user to upload their resume/CV file (accept PDF/DOC/DOCX formats). Validate file type and size, and store the file in the configured storage.
- [ ] **2.1.3**: Update the database to link uploaded CVs to users (e.g. add fields in the Profile or a separate CV table: userId, file path, upload date, processing status).
- [ ] **2.1.4**: After storing the file, trigger the **CV Processing workflow** (OCR and AI analysis) asynchronously. Mark the CV record with a "processing" status initially.
- [ ] **2.1.5**: Implement backend logic to handle different file formats: if the CV is already text-based (PDF or DOCX), extract text directly; if it's an image or scanned PDF, use OCR to extract text (this will be detailed in AI Integration section).
- [ ] **2.1.6**: Develop the front-end component for **CV Upload** (an upload button or drag-and-drop area on the profile/CV page). Ensure it shows file selection and a loading/progress indicator during upload.
- [ ] **2.1.7**: Integrate the front-end upload component with the CV Upload API (handle sending the file via multipart form-data, and handle the API response).
- [ ] **2.1.8**: Provide UI feedback for CV upload status – e.g. show "CV uploaded, processing…" message to the user after upload is successful and processing has started.
- [ ] **2.1.9**: Once processing is complete (could poll the server or get a notification), update the UI to reflect that the CV is ready/processed (or show any errors if processing failed).
- [ ] **2.1.10**: Implement a backend method to retrieve the processed CV results (anonymized text, analysis data) when requested by the user or needed in other features.
- [ ] **2.1.11**: Allow users to **replace or delete their CV**: create endpoints to delete an existing CV or upload a new version (with appropriate warnings or confirmations on the UI).
- [ ] **2.1.12**: Ensure proper permissions: only the owner (or admin) can upload/replace/delete a CV for that profile.
- [ ] **2.1.13**: Write integration tests for the CV upload endpoint (simulate file upload, ensure the file is saved and a processing job is triggered, and that unauthorized uploads are rejected).
- [ ] **2.1.14**: Handle error cases on front-end: display a user-friendly message if the upload fails (due to network, file type not allowed, size too large, etc.) and allow retry.

### 2.2 AI-based Analysis & Anonymization
- [ ] **2.2.1**: After CV text is extracted, use an **AI service** (e.g. OpenAI API) to analyze the CV content. Define the analysis goals: extract structured data (skills, experience, education), and identify personal identifiable information (PII) for removal.
- [ ] **2.2.2**: Implement the integration with the AI API for CV analysis (send the extracted text with a prompt that requests summarization and PII detection). Parse the AI response to get key info and an anonymized version of the text.
- [ ] **2.2.3**: Develop a function to **anonymize the CV** by removing or redacting PII (name, contact info, etc.) from the text. Use AI results combined with regex/pattern matching to ensure all personal data is removed.
- [ ] **2.2.4**: Save the **anonymized CV text** and extracted key information to the database (e.g. save anonymized text in the CV record, save extracted skills or summary in profile fields or a separate table).
- [ ] **2.2.5**: Mark the CV record's status as "processed" and store a timestamp when analysis is complete.
- [ ] **2.2.6**: Implement logging and error handling for the analysis process: if the AI service fails or times out, catch the error, mark CV as "analysis failed", and perhaps retry or notify admin.
- [ ] **2.2.7**: Develop the front-end to display analysis results to the user: e.g. show a summary of their CV (skills, experience years, etc.) and confirm that personal info is hidden. This could be on their profile page as an "Analyzed CV Summary" section.
- [ ] **2.2.8**: If applicable, allow the user to provide corrections to anonymization (e.g. if some personal detail slipped through, they can edit/remove it) – one-story-point task for a simple interface to manually redact additional info.
- [ ] **2.2.9**: Ensure the anonymized CV can be **viewed by recruiters** without exposing personal info. (This will tie into candidate search results and contact requests: recruiters see the anonymized profile/CV).
- [ ] **2.2.10**: Write unit tests for the anonymization function (e.g. input sample text with email/phone, ensure output has them removed). If possible, mock the AI API to test the integration logic.
- [ ] **2.2.11**: Write an integration test for the full CV processing pipeline on the backend (simulate uploading a CV file and ensure that eventually an anonymized result is produced in the database).

### 2.3 CV Privacy & Analytics
- [ ] **2.3.1**: Implement a **CV Privacy Setting** for users – e.g. a toggle "Allow recruiters to find my anonymized CV in search". Store this preference in the user profile.
- [ ] **2.3.2**: Enforce CV privacy: update any recruiter search queries (from Contact Requests feature) to only include candidates who have opted in to being discoverable.
- [ ] **2.3.3**: Implement an **Analytics Tracking** for CV views – whenever a recruiter views a candidate's anonymized CV/profile, record an event (who viewed, when) in a CV view log table.
- [ ] **2.3.4**: Track contact requests events as well (when a recruiter sends a request after viewing a CV). This ties into analytics of CV effectiveness.
- [ ] **2.3.5**: Create a **User Dashboard section** for job seekers to see analytics about their CV: e.g. "Your CV has been viewed X times by recruiters this week" or "You appeared in Y search results".
- [ ] **2.3.6**: Implement the backend logic to compute these CV analytics for a user (aggregate counts of views, contact requests, etc. from the log data).
- [ ] **2.3.7**: Develop the front-end UI for displaying CV analytics to the user (could be on the profile page or a separate dashboard page). Include graphs or simple counts (one-story-point for a basic text or simple chart component).
- [ ] **2.3.8**: Ensure that viewing analytics does not leak identity of the recruiters (just show aggregate numbers, unless a feature is to show which companies viewed – likely not for privacy reasons).
- [ ] **2.3.9**: Implement a **candidate search feature** for recruiters: a backend API that allows recruiters to query anonymized CVs by skill keywords, location, experience, etc. (respects the privacy setting).
- [ ] **2.3.10**: Develop a front-end **Candidate Search Page** for recruiters, with filters (skills, location, etc.) to find matching candidates. Show results as a list of anonymized profiles (e.g. role, summary of skills, industry, but no name/contact).
- [ ] **2.3.11**: Integrate the contact request action in candidate search results (each result item has a "Contact" button that triggers the request workflow).
- [ ] **2.3.12**: Test the privacy controls by attempting candidate searches with both opt-in and opt-out users to ensure only intended profiles appear.
- [ ] **2.3.13**: Test analytics calculations for accuracy (simulate known events and verify the dashboard shows correct counts for views and requests).

## 3. Job Listings

### 3.1 Aggregation & Scraping
- [ ] **3.1.1**: Identify external job sources for aggregation (e.g. LinkedIn, Indeed, company career pages, etc.) and decide on scraping method or API usage for each.
- [ ] **3.1.2**: Implement a **Job data model** in the database to store aggregated jobs (fields: job title, company, location, description, requirements, source, URL, post date, etc.).
- [ ] **3.1.3**: For each chosen source, implement a **Scraper or API integration** to collect job listings:
  - [ ] **3.1.3.1**: Implement scraper for Source A (e.g. Indeed): fetch job listings for relevant categories/keywords, parse job attributes into the Job model.
  - [ ] **3.1.3.2**: Implement scraper for Source B (e.g. LinkedIn or others) with proper API calls or HTML parsing.
  - [ ] **3.1.3.3**: (Repeat for additional sources as needed, each as a one-story-point task).
- [ ] **3.1.4**: Create a scheduled job (cron) or background worker to run the scraping at defined intervals (e.g. daily or hourly) to keep job listings up-to-date.
- [ ] **3.1.5**: Implement logic to avoid duplicate job entries: check for existing job by title/company/location (and perhaps date) before inserting new, or update existing entry if details changed.
- [ ] **3.1.6**: Add error handling and logging in the scraping process: if a source fails (site down or HTML changed), log the error and continue with others; notify admin via admin panel metrics or email if repeated failures occur.
- [ ] **3.1.7**: Ensure compliance with source usage policies: if using APIs, abide by rate limits; if scraping HTML, respect robots.txt and do not overload their servers (throttle requests).
- [ ] **3.1.8**: Populate the initial job listings database by running the scrapers and verify that jobs are saved correctly with all required fields.
- [ ] **3.1.9**: Write unit tests for any parsing functions (e.g., given sample HTML or API response, ensure the data maps to our Job model properly).
- [ ] **3.1.10**: Write an integration test for the aggregation workflow (perhaps mock one source's response and test the end-to-end insertion of a job entry in our database).

### 3.2 Job Discovery & Filtering
- [ ] **3.2.1**: Implement a backend API endpoint for **Job Search** that allows querying the jobs database with filters such as keyword (search in title/description), location, company, job type, etc.
- [ ] **3.2.2**: Add support for pagination on the job search API (limit and offset or page number) to handle large results sets.
- [ ] **3.2.3**: Implement sorting options in the job search (e.g. by most recent, or relevance if a search term is used).
- [ ] **3.2.4**: Create a **Job Listing Page** on the front-end that displays a list of jobs with basic info (job title, company, location, snippet of description).
- [ ] **3.2.5**: Develop a **Job Filters UI** component on the front-end for users to refine job search (fields for keyword, location autocomplete or dropdown, maybe checkboxes for job type or remote).
- [ ] **3.2.6**: Integrate the filters UI with the search API: on filter change or form submit, call the API and refresh the job list.
- [ ] **3.2.7**: Implement a **Job Details Page** on the front-end that shows the full job description, requirements, company info, and an "Apply" button or external link to the original posting.
- [ ] **3.2.8**: Ensure the "Apply" link either opens the external job URL in a new tab or, if we support internal applications in future, prepare a placeholder for that.
- [ ] **3.2.9**: Implement a feature for job seekers to **save/bookmark jobs** they are interested in:
  - [ ] **3.2.9.1**: Backend API to save a job (linking user and job in a SavedJobs table).
  - [ ] **3.2.9.2**: Front-end UI (e.g. a star icon or save button on job listings and details) to toggle saved status.
  - [ ] **3.2.9.3**: A front-end page or section to view saved jobs list.
- [ ] **3.2.10**: Integrate the **job matching algorithm** results: on the user's dashboard or a "Recommended Jobs" page, display jobs that the AI matching system found to be a good fit for the user.
- [ ] **3.2.11**: Implement the front-end for **Recommended Jobs** – possibly as a section on the home/dashboard after login (list top N recommended jobs with a link to see more).
- [ ] **3.2.12**: Ensure that job search and recommendation displays consider the user's profile (e.g. location preferences if known, or hide jobs the user already saved/applied).
- [ ] **3.2.13**: Write integration tests for job search API (test filtering by keyword, location, combination of filters, and that pagination works).
- [ ] **3.2.14**: Write end-to-end tests for the job discovery front-end (simulate entering a search query, receiving results, clicking a job to view details, etc.).
- [ ] **3.2.15**: Optimize search queries with appropriate database indexing (e.g. index on job title or location) to ensure the filtering is efficient even as data grows.

### 3.3 Job Analytics
- [ ] **3.3.1**: Implement tracking for user interactions with jobs: whenever a user clicks on a job listing or the apply link, record an event (user, job, timestamp, action type like "view" or "apply click").
- [ ] **3.3.2**: Record job saving events and unsave events similarly, to analyze engagement with job postings.
- [ ] **3.3.3**: If applicable, track when a job posting is scraped vs when it expires (or is no longer available) so we can measure how long postings stay active. Mark jobs as inactive or remove them when expired.
- [ ] **3.3.4**: Create analytics queries or cron jobs to compute job-related metrics such as:
  - Total number of jobs aggregated (active vs expired).
  - Number of new jobs added per day/week.
  - Most popular jobs (by views or saves).
  - Click-through rate: views vs apply clicks for each job (if measurable).
- [ ] **3.3.5**: Integrate job metrics into the admin panel dashboard (e.g. show number of active jobs, top 5 most-viewed jobs, etc. in Admin Analytics).
- [ ] **3.3.6**: If recruiters/companies will eventually post jobs on the platform, implement placeholders for future metrics per job posting (views, applications via platform), but since currently using external apply, focus on what we can track (clicks, saves).
- [ ] **3.3.7**: Implement a cleanup mechanism for old job listings: e.g. if a job is older than X days, consider marking it expired or remove to keep the list current (and reflect this in metrics).
- [ ] **3.3.8**: Ensure that analytics logging does not noticeably slow down the user actions (use asynchronous logging or batch inserts for events).
- [ ] **3.3.9**: Write tests for the analytics logging functions (simulate a job view action and verify the event is recorded properly).
- [ ] **3.3.10**: Verify analytics correctness by manually comparing a sample user session (views/saves) with the data recorded in the database, ensuring metrics make sense.

## 4. Messaging & Notifications

### 4.1 Contact Requests System
- [ ] **4.1.1**: Design a **ContactRequest** model in the database with fields: requesting user (recruiter), target user (candidate), optional message or job reference, status (pending/accepted/declined), timestamps.
- [ ] **4.1.2**: Implement a backend API endpoint for recruiters to **Send Contact Request** to a candidate:
  - Validate that the requester is a recruiter with an active subscription/permissions.
  - Validate that the target candidate has allowed contact (CV privacy opt-in) and hasn't blocked requests.
  - Create a ContactRequest entry with status "pending" and store any introductory message and context (e.g. which job posting prompted this contact, if applicable).
- [ ] **4.1.3**: Implement a backend API endpoint for candidates to **Respond to Contact Request**:
  - Accept request: update status to "accepted", trigger an email or notification to the recruiter with candidate's contact info or open a messaging channel.
  - Decline request: update status to "declined", (optionally allow candidate to send a polite decline message), notify recruiter of decline.
- [ ] **4.1.4**: If a contact is accepted, determine how communication proceeds:
  - Option 1: **Reveal contact info** – Provide the recruiter's email to the candidate and candidate's email to the recruiter so they can communicate off-platform.
  - Option 1: **Reveal contact info** – Provide the recruiter's email to the candidate and candidate's email to the recruiter so they can communicate off-platform.
  - Option 2: **In-app Messaging** – Create a Message thread (see 4.1.6) and allow back-and-forth messages within the platform.
  - Implement one of these as a one-story-point decision (assuming in-app messaging for richer feature).
- [ ] **4.1.5**: Develop front-end **Recruiter Interface for Contact**:
  - On a candidate's anonymized profile (from search results), include a "Contact Candidate" button.
  - On a candidate's anonymized profile (from search results), include a "Contact Candidate" button.
  - Clicking opens a form modal for the recruiter to write an optional message and confirm sending the contact request.
  - Integrate this form with the Send Contact Request API and handle success/failure (showing confirmation or errors).
- [ ] **4.1.6**: Develop front-end **Candidate Interface for Requests**:
  - Create a **Contact Requests Page** listing incoming contact requests (with recruiter name, company, message, and buttons to accept/decline).
  - If using in-app messaging, accepting a request could redirect to a new **Message Thread** page to chat; if revealing contact info, show the recruiter's contact.
  - Ensure real-time update or refresh after responding (the request disappears or shows status updated).
- [ ] **4.1.7**: Implement an internal **Messaging System** (if chosen):
  - Define a **Message** model (sender, recipient, content, timestamp, thread or request link).
  - Backend endpoints for sending a message in a thread (only accessible if a contact request is accepted and both users authorized in that thread).
  - Endpoint for fetching messages in a conversation (with pagination if needed).
  - Basic typing indicator or read receipt could be skipped for now (to keep tasks small).
- [ ] **4.1.8**: Develop the front-end **Messaging UI** (if applicable):
  - A simple chat interface showing message history and an input box to send new messages.
  - Poll the server for new messages or use web socket if available (web socket setup could be additional story-point tasks, else simple polling).
  - Display new messages in real-time (or on refresh) for both recruiter and candidate.
- [ ] **4.1.9**: Ensure that if a contact request is accepted and messaging is used, both parties receive a notification (and maybe an email) about the new messaging channel available.
- [ ] **4.1.10**: Add checks to avoid duplicate contact requests: e.g. a recruiter shouldn't send multiple pending requests to the same candidate. If one is pending or was recently declined, handle accordingly (maybe prevent or warn).
- [ ] **4.1.11**: Implement limits or throttling on contact requests if needed (e.g. a recruiter can only send X requests per day on a basic plan – this ties into subscription management).
- [ ] **4.1.12**: Write unit tests for contact request creation logic (permissions, invalid cases like contacting without subscription or duplicate request).
- [ ] **4.1.13**: Write integration tests for the contact request flow: a recruiter sends request, candidate accepts, verify the state changes and appropriate notifications or data (like contact info reveal or message thread creation).
- [ ] **4.1.14**: If in-app messaging is implemented, write integration tests for sending and retrieving messages in a thread (including security so only participants can fetch messages).

### 4.2 Notification Handling
- [ ] **4.2.1**: Design a **Notification** model to store in-app notifications (fields: user, type [e.g. "New Contact Request", "Request Accepted", "New Message", "Job Match"], message content or reference ID, read/unread flag, timestamp).
- [ ] **4.2.2**: Implement backend logic to **Create Notifications** for relevant events:
  - When a candidate receives a new contact request (create a notification for the candidate).
  - When a recruiter's request is accepted or declined (notification for the recruiter).
  - When a new message is received (notification for the recipient if not currently viewing the chat).
  - (Optional) When new job matches are available or other periodic alerts.
- [ ] **4.2.3**: Implement a backend API endpoint to **Fetch Notifications** for the logged-in user, possibly with filter (unread only or all) and pagination if many.
- [ ] **4.2.4**: Implement a backend API endpoint or method to **Mark Notifications as Read** (e.g. when user views their notification list or clicks a notification).
- [ ] **4.2.5**: Develop the front-end **Notifications UI**:
  - A bell icon or notifications dropdown in the nav bar showing a count of unread notifications.
  - A **Notifications Page or Panel** listing all notifications with their details and links (e.g. clicking "Contact request from X" opens that request or profile).
  - Ensure that unread notifications are highlighted and marked read when viewed.
- [ ] **4.2.6**: Implement real-time or polling updates for notifications:
  - Use periodic polling (e.g. every 30 seconds) to check for new notifications if the user is online, OR
  - Integrate WebSockets or a service like Firebase for push notifications (one-story-point to set up a basic WebSocket server broadcasting notifications to authenticated clients).
- [ ] **4.2.7**: Integrate email notifications for important events:
  - Send an email to the candidate when they get a new contact request (with a link to the site).
  - Send an email to the recruiter when a request is accepted with contact info or next steps.
  - Use a templating system for emails; ensure to honor user email preferences (e.g. an unsubscribe setting).
- [ ] **4.2.8**: Provide a **Notification Preferences** setting in the user profile (e.g. toggle email notifications on/off for new requests, etc.) and implement logic to respect these settings when sending emails.
- [ ] **4.2.9**: Test the notification system by simulating events: create a contact request and ensure the candidate gets an in-app notification (and email if enabled); accept a request and ensure the recruiter gets notified, etc.
- [ ] **4.2.10**: Write unit tests for the notification creation functions (given an event, the correct Notification object is created with expected content).
- [ ] **4.2.11**: Write an integration test for the notifications API (ensure that fetching notifications returns those related to the user and marks them read correctly).

## 5. Payment Processing

### 5.1 Subscription Management
- [ ] **5.1.1**: Define subscription plans and access levels for the platform (e.g. Free vs Premium recruiter accounts). Determine benefits: e.g. free recruiters can send 0 or limited contact requests, Premium can send more or unlimited, etc.
- [ ] **5.1.2**: Update the User model to include subscription status or a separate Subscription model (fields: user, plan type, start date, end date, active flag, etc.).
- [ ] **5.1.3**: Implement logic to **gate features** based on subscription:
  - In contact request API, check subscription before allowing sending (free tier exceeded limit -> return an error instructing to upgrade).
  - Possibly limit candidate search results or other features for free tier if applicable.
- [ ] **5.1.4**: Create a **Subscription Purchase Page** on the front-end where recruiters can choose a plan (monthly/yearly) and initiate payment (this will integrate with Stripe checkout in 5.2).
- [ ] **5.1.5**: Display current subscription status in the recruiter's account settings or profile (e.g. "Plan: Free" or "Pro – expires on 2025-12-31").
- [ ] **5.1.6**: Implement a backend API to get subscription status and allowed usage (e.g. how many contact requests remaining for this billing period for free tier).
- [ ] **5.1.7**: Implement usage tracking for limited features:
  - Each time a recruiter sends a contact request, increment their usage count for the current period.
  - If they have a quota (e.g. 5 requests per month on free), prevent sending if quota reached.
  - Reset or roll over counts at the start of a new billing cycle (for paid plans) or monthly for free.
- [ ] **5.1.8**: Create an **Upgrade Prompt**: if a free user tries to use a premium feature (like sending another request after quota), show a modal or message prompting upgrade with a link to the Subscription Purchase Page.
- [ ] **5.1.9**: Implement a backend endpoint to **Cancel Subscription** (or integrate Stripe customer portal link) which will downgrade the user after the current period ends.
- [ ] **5.1.10**: Ensure that downgrading or expiring subscriptions updates user privileges accordingly (e.g. once premium expires, set user back to free status and enforce limits).
- [ ] **5.1.11**: Test subscription gating by simulating a user with each plan: ensure free users are blocked appropriately and premium users have access. Write unit tests for the function that checks permissions based on plan.
- [ ] **5.1.12**: Write integration tests for subscription changes: e.g. simulate a webhook or admin action that upgrades a user and verify they can now send more requests, and simulate expiry to ensure features lock again.

### 5.2 Stripe Integration & Billing
- [ ] **5.2.1**: Set up a Stripe account and obtain API keys for test and production. Securely store the Stripe secret key in the backend configuration.
- [ ] **5.2.2**: Create **Products and Pricing** in Stripe for the subscription plans (e.g. "Premium Recruiter Monthly" and/or "Yearly" with corresponding prices).
- [ ] **5.2.3**: Implement a backend API endpoint to create a **Stripe Checkout Session** for the selected plan:
  - The endpoint receives the plan ID, quantity (usually 1 subscription), and the authenticated user's identifier.
  - Use Stripe API to create a checkout session (specify success and cancel return URLs, customer email to prefill, etc.).
  - Return the session URL to the front-end.
- [ ] **5.2.4**: Integrate front-end on the Subscription Purchase Page: when user selects a plan and clicks "Purchase", call the checkout session API, then redirect the user's browser to the Stripe Checkout URL.
- [ ] **5.2.5**: Implement a **Stripe Webhook Handler** on the backend to listen for subscription events:
  - Handle `checkout.session.completed` (mark subscription as active for user, store Stripe subscription ID, next billing date, etc.).
  - Handle `invoice.payment_failed` or `customer.subscription.deleted` (mark subscription as canceled or inactive when payments fail or subscription ends).
  - Verify webhook signatures for security.
- [ ] **5.2.6**: After a successful checkout, on the front-end, implement a **Post-Checkout Landing**:
  - A "Subscription Successful" page that the user is redirected to (the success URL) after payment, which calls backend to confirm their subscription status and thanks them.
  - A "Subscription Canceled" page (the cancel URL) if they abandon payment, which informs them the purchase was not completed.
- [ ] **5.2.7**: Implement functionality to update the Stripe customer with user info:
  - If not already created, create a Stripe Customer for the user when they first go to checkout (include email).
  - Store the Stripe customer ID in our database for future reference (e.g. to allow portal access or additional purchases).
- [ ] **5.2.8**: Provide a way for users to **manage billing** (update card, cancel) via Stripe:
  - E.g. generate a Stripe **Customer Portal** link (Stripe provides a hosted billing portal) and link to it from account settings for convenience.
- [ ] **5.2.9**: Test the Stripe integration in test mode thoroughly:
  - Simulate a successful payment flow (Stripe's test card numbers) and verify our database updates correctly (user now premium, subscription record dates).
  - Simulate payment failure (use a test card that triggers failure) and ensure system handles it (maybe retry or mark as failed).
  - Simulate webhook events via Stripe CLI or dashboard to ensure our webhook handling logic works.
- [ ] **5.2.10**: Ensure that all Stripe-related errors are handled gracefully:
  - If creating a checkout session fails, the API should return an error that the front-end can display.
  - Log any unexpected webhook events or mismatches for debugging.
- [ ] **5.2.11**: For security, ensure that the front-end cannot manipulate plan prices or IDs (always rely on backend to set the actual amount from trusted data, not from what user passed).
- [ ] **5.2.12**: Write unit tests for any custom Stripe logic (if mocking Stripe SDK, test that our code reacts correctly to events). Integration tests might be limited (could use Stripe test mode, or mock webhook calls in tests).

## 6. Admin Panel

### 6.1 User & Content Moderation
- [ ] **6.1.1**: Extend the User model with an **admin role/flag** to designate certain users as administrators.
- [ ] **6.1.2**: Implement an **Admin Login** or modify existing login to allow admin access (could be the same login but restrict admin pages to admin users based on the flag).
- [ ] **6.1.3**: Create a restricted area in the backend (prefix routes with `/admin` or similar) that checks the admin authorization on each request.
- [ ] **6.1.4**: Develop the front-end **Admin Dashboard Page** as a landing for admin users after login, with summary stats (users count, active jobs count, etc.) and navigation to other admin sections.
- [ ] **6.1.5**: Implement an **Admin User Management Page**:
  - Back-end: Endpoint to list users (possibly paginated) and search users by email/name.
  - Back-end: Endpoint to update a user's status (e.g. deactivate/ban a user, or upgrade a user to recruiter or admin role).
  - Front-end: Table view of users with columns (Name, Email, Role, Status, actions to deactivate or change role).
  - Include the ability to filter or search users by name/email.
- [ ] **6.1.6**: Implement functionality for **User Deactivation/Ban**:
  - Admin can deactivate a user account (set a flag in DB).
  - Ensure deactivated users cannot log in (add check in auth) and perhaps their content (CV, profile) is hidden.
  - Provide a way to reactivate if needed.
- [ ] **6.1.7**: Implement an **Admin Content Review Page** for CVs or profiles:
  - List recent CV uploads and their anonymized output for spot-checking.
  - Option to remove a CV if it contains inappropriate content or fails anonymization.
  - (If users can post other content like comments or future features, include moderation for those, but currently primarily CVs).
- [ ] **6.1.8**: Implement an **Admin Job Listings Page**:
  - List all aggregated jobs, with ability to search/filter.
  - Actions to remove or hide a job if it's inappropriate or duplicated.
  - Possibly mark certain sources as temporarily off if they provide bad data.
- [ ] **6.1.9**: Implement a **Reports/Flagged Content System** (if users can report issues):
  - Allow candidates to report abusive messages or recruiters.
  - Allow recruiters to report fake profiles.
  - Backend: model for reports (reporter, reported user/content, reason, status).
  - Front-end: simple form to submit a report from relevant context (profile or message).
  - Admin Page to view open reports and take action (e.g. warning, ban user, etc.).
- [ ] **6.1.10**: Ensure all admin actions are logged (audit log): e.g. if an admin bans a user or deletes a job, record which admin did it and when, in case of auditing.
- [ ] **6.1.11**: Implement front-end routing and navigation for admin pages, separate from normal user nav (e.g. a sidebar or menu on the admin dashboard linking to Users, Jobs, Reports, etc.).
- [ ] **6.1.12**: Test admin permissions thoroughly:
  - Verify that non-admin users cannot access admin APIs or pages (e.g. try to call admin endpoints as normal user and ensure 403 Forbidden).
  - Verify admin users can perform each action and that the results are reflected (user banned actually cannot login, etc.).
- [ ] **6.1.13**: Write unit tests for critical admin operations (e.g. changing user roles, banning user logic).
- [ ] **6.1.14**: Write integration tests for admin endpoints (e.g. fetch users list, update user role, ensure changes in database).
- [ ] **6.1.15**: (Optional) Implement role-based access in a flexible way to accommodate future roles (maybe an enum or bitmask of permissions, but for now just user vs admin vs recruiter is sufficient).

### 6.2 Analytics & Platform Metrics
- [ ] **6.2.1**: Identify key platform metrics to display in the admin dashboard:
  - Total users, and breakdown by type (job-seekers vs recruiters).
  - Daily/Monthly Active Users (if trackable).
  - Number of CVs uploaded.
  - Number of contact requests sent, accepted, declined.
  - Number of active job listings in the system.
  - Subscription stats: number of paying recruiters, revenue (if needed for admin).
- [ ] **6.2.2**: Implement backend endpoints or services to gather these metrics:
  - Query the database for user counts, job counts, etc.
  - If needed, maintain a separate analytics collection updated daily for trending data (to avoid heavy real-time queries).
- [ ] **6.2.3**: Develop the **Admin Analytics Dashboard UI**:
  - Use cards or charts to display the metrics identified.
  - Example: A chart of user signups over time (requires capturing daily signups count).
  - A chart or list for contact requests (e.g. how many per week, acceptance rate).
  - Financial stats if applicable (from Stripe, e.g. total revenue this month).
- [ ] **6.2.4**: Implement data collection for time-series metrics:
  - e.g. create a daily cron job to record stats like total users, total jobs, etc. into an `Analytics` table with a date, so we can chart growth over time.
  - Alternatively, calculate on the fly for recent period if dataset is small (one-story-point decision).
- [ ] **6.2.5**: Integrate real-time metrics:
  - For metrics that change in real-time and are cheap to query (like total users), query directly when admin dashboard loads.
  - For heavier metrics (like breakdowns over time), use precomputed data or limit the range (e.g. last 30 days).
- [ ] **6.2.6**: Implement an admin view for **User Growth**:
  - A section or chart showing new registrations per day/week. (Requires storing timestamp on user creation and querying counts by day).
- [ ] **6.2.7**: Implement an admin view for **Engagement**:
  - e.g. average number of contact requests per recruiter, or percentage of candidates with at least one contact, etc. (Combine data from various models).
- [ ] **6.2.8**: Secure the analytics endpoints (admin-only) and ensure they are optimized (add indexes on date fields, etc., for grouping by date queries).
- [ ] **6.2.9**: Test the analytics data for accuracy by comparing against raw data:
  - e.g. manually count users in DB vs the number shown on dashboard.
  - Trigger some events (like create a contact request) and see that it reflects in metrics if applicable (maybe next day if using daily cron).
- [ ] **6.2.10**: Write unit tests for any utility functions used in computing analytics (like calculations of rates or parsing data into chart format).
- [ ] **6.2.11**: (Optional) Integrate an external analytics or monitoring service if needed (like Google Analytics for page views, or Mixpanel for event tracking, if those metrics are needed outside admin – not explicitly required, skip if out of scope).

## 7. AI Integrations

### 7.1 CV Processing Workflow (OCR + OpenAI Analysis)
- [ ] **7.1.1**: Choose an OCR solution for extracting text from resumes (e.g. Tesseract OCR for images or use a library for PDF text extraction). Install and configure it in the backend environment.
- [ ] **7.1.2**: Implement a function to **extract text from the CV file**:
  - If PDF or Docx (with text), use a parser library to get raw text.
  - If image-based PDF or image file, use the OCR library to retrieve text.
  - Normalize and clean the text (remove excessive whitespace, non-printable characters).
- [ ] **7.1.3**: Set up integration with the **OpenAI API** (or another ML model) for analyzing the CV text. Store the API key securely and install any SDK if provided.
- [ ] **7.1.4**: Define the **prompt or approach** for AI analysis of CV:
  - For example, craft a prompt that asks the AI to output JSON with fields: name, email, phone, top skills, years of experience, education, summary, etc., derived from the resume text.
  - Alternatively, plan a series of prompts: one to identify PII, one to summarize skills (depending on API limits and costs).
- [ ] **7.1.5**: Implement the backend **AI Analysis function**:
  - Send the extracted CV text to OpenAI (with the prompt designed to get structured data).
  - Receive and parse the response (e.g. parse JSON or text into our data structures).
  - If the AI returns PII (personal info) and other details, separate those out for anonymization.
  - If the AI returns a summary or categorized info (skills list, etc.), store them appropriately.
- [ ] **7.1.6**: Integrate anonymization: using the PII identified (or using regex on common patterns as backup), remove personal identifiers from the CV text to produce the anonymized version.
- [ ] **7.1.7**: Populate the results into the system:
  - Update the CV record with anonymized text.
  - Update the user's profile with extracted structured data: e.g. fill a "Key Skills" field or a "Summary" field for the user (if we want to use that for matching/search).
  - Save any other insights (like years of experience calculated or degree obtained).
- [ ] **7.1.8**: Ensure this processing workflow can be done asynchronously (to avoid long blocking requests):
  - Possibly implement it as a background job in a queue (one-story-point: set up a job queue system, e.g. Bull for Node or RQ for Python, to handle OCR+AI tasks).
  - The CV Upload endpoint would enqueue the job and immediately return, and the front-end would poll for completion (as handled in section 2.1).
- [ ] **7.1.9**: Handle OpenAI API limitations:
  - Implement rate limiting or queueing if multiple CVs are processed concurrently.
  - Catch errors from the API (e.g. request too long, or API downtime) and implement a retry mechanism or default to a simpler analysis if AI fails.
  - Possibly break the resume text into chunks if too large for one prompt, and handle accordingly.
- [ ] **7.1.10**: Write unit tests for the text extraction function (using sample files as fixtures to ensure OCR and parsers work as expected).
- [ ] **7.1.11**: Write unit tests or integration tests for the AI analysis function:
  - This may involve mocking the OpenAI API response (to test our parsing and handling logic without actual API calls).
  - Test that a known input text yields the expected structured output in our system.
- [ ] **7.1.12**: Test the entire CV processing pipeline in a development environment with a real sample resume:
  - Verify that the text is extracted, AI returns data, PII is removed, and the anonymized profile info is correctly saved and displayed to the user.
  - Adjust prompt or parsing as necessary based on results.
- [ ] **7.1.13**: Monitor the performance of the CV processing:
  - Check how long an average CV takes to process.
  - Ensure this is acceptable, or if not, consider optimizations (like using a smaller model or caching results for identical CVs, etc.).
- [ ] **7.1.14**: (Optional) If OpenAI usage cost is a concern, implement a usage log and maybe restrict number of analyses per user or per day (or allow re-processing only if profile significantly changes).
- [ ] **7.1.15**: (Optional) Explore using the AI analysis to improve user profile automatically:
  - e.g. offer to populate the user's profile fields (skills, experience) from their CV data as a convenience (one-story task if decided to implement).

### 7.2 Job Matching Algorithm
- [ ] **7.2.1**: Define the criteria for job matching:
  - Identify what data from a candidate profile/CV to use (e.g. skills, desired role, location).
  - Identify what data from job listings to match on (e.g. required skills, job title keywords, location).
  - Decide on a scoring system (for example, +X points for each matching skill, +Y if locations match or job is remote and user open to remote, etc.).
- [ ] **7.2.2**: Implement a function to **compute match score** between a single candidate profile and a single job:
  - e.g. take arrays of candidate skills and job required skills -> compute overlap.
  - Check location match (or distance if location-based).
  - Perhaps use keyword similarity between candidate's desired title (or current title) and job title.
  - Normalize the score to a range (like 0-100).
- [ ] **7.2.3**: Implement the **job matching algorithm** that goes through all jobs (or a subset of relevant jobs) for a given candidate and finds top N matches:
  - Could be as simple as filtering jobs where some skills overlap and then sorting by score.
  - Or more complex like using vector embeddings of text (one-story-point if using AI to embed job description and candidate profile and then cosine similarity).
  - Start with a simple rule-based approach for clarity and performance.
- [ ] **7.2.4**: Create a scheduled process or on-demand trigger for matching:
  - Option 1: Every time a CV is processed or profile is updated, compute that user's top job matches and store them.
  - Option 2: Compute on demand when the user visits their recommended jobs page (and cache the result for a session).
  - Implement one of these approaches.
- [ ] **7.2.5**: Design a storage for match results if needed:
  - e.g. a table of RecommendedJobs (user, job, score, generatedDate) to store the top matches so it can be quickly fetched for UI.
  - Or just generate on the fly each time (with caching).
- [ ] **7.2.6**: Integrate the matching results with the UI:
  - Ensure the Recommended Jobs section (from 3.2.10/3.2.11) pulls either the precomputed recommendations or triggers a match compute.
  - Include match score or indicators in the UI if desired (like "Strong match" vs "Moderate match" based on score thresholds).
- [ ] **7.2.7**: Evaluate the quality of matches:
  - Test the algorithm with a variety of test profiles and job postings to see if results seem relevant.
  - If not, adjust weighting (e.g. maybe some skills are more important than others, or add requirements that at least one skill must match).
- [ ] **7.2.8**: (Optional) Incorporate feedback loop:
  - If the user dismisses a recommended job or clicks "not interested", record that and perhaps lower the score of similar jobs in the future.
  - If user clicks or saves a recommended job, consider that a positive signal.
  - This could be complex; one-story-point to log feedback for future improvement, even if not immediately used.
- [ ] **7.2.9**: Write unit tests for the match scoring function (e.g. known sets of skills and job requirements yield expected scores).
- [ ] **7.2.10**: Write integration tests for the matching algorithm:
  - e.g. set up a test user profile with certain skills, create a few test jobs in DB with overlapping skills, run the match routine, and verify the top results and scores.
- [ ] **7.2.11**: Optimize the matching as data scales:
  - If jobs are numerous, ensure the algorithm can handle it (maybe add indexes or use a search engine like Elasticsearch for matching if necessary – optional future improvement).
  - For now, test performance with a reasonable dataset size (e.g. 10k jobs) to ensure it's not too slow.
- [ ] **7.2.12**: Document the matching approach within code or docs so that future iterations or AI improvements can be made with understanding of the current baseline.

## 8. Frontend & Storybook Component Breakdown

### 8.1 Common Layout & Storybook Setup
- [x] **8.1.1**: Set up the front-end project structure (using a framework like React/Vue/Angular). Configure routing (for multi-page SPA routes like login, profile, jobs, admin, etc.).
- [x] **8.1.2**: Implement a **Main Navigation Bar** component (common top nav with site logo, menu links for Jobs, Profile, Notifications icon, etc., and conditionally Login/Signup or user menu if logged in).
- [x] **8.1.3**: Implement a **Footer** component (with basic information, copyright, maybe links to terms/privacy).
- [x] **8.1.4**: Create a **Layout wrapper** component that includes the nav bar and footer and a content area for pages (to ensure consistency across pages).
- [x] **8.1.5**: Set up Storybook for the front-end: install Storybook, add necessary loaders for CSS/images, and verify it runs.
- [x] **8.1.6**: Create a Storybook story for the **Navigation Bar** component (showing default state, logged-in vs logged-out states).
- [x] **8.1.7**: Create a Storybook story for the **Footer** component.
- [x] **8.1.8**: Implement global styles or theme (decide on color scheme, typography). If using a design library (like Material-UI, Bootstrap, etc.), configure it or if custom, set up CSS/Sass structure.
- [x] **8.1.9**: Ensure the app is responsive: define breakpoints for mobile vs desktop views in the layout and test that nav/footer adjust accordingly.
- [x] **8.1.10**: Test in Storybook and in the app that the common layout components render correctly on different screen sizes.

### 8.2 Authentication Pages & Components with Supabase Auth
- [ ] **8.2.1**: Set up Supabase Auth with project API keys:
  - [ ] **8.2.1.1**: Configure Supabase project settings for Auth, including site URL and redirect URLs.
  - [ ] **8.2.1.2**: Set up the Supabase client in the application.
- [ ] **8.2.2**: Implement the **Magic Link Authentication Component**:
  - [ ] **8.2.2.1**: Email input field component with validation.
  - [ ] **8.2.2.2**: Submit button to send magic link.
  - [ ] **8.2.2.3**: Success and error message display areas.
- [ ] **8.2.3**: Create a Storybook story for the **Magic Link Component** (showing default state, loading state, success state, and error state).
- [ ] **8.2.4**: Set up **Social Login Providers** in Supabase dashboard:
  - [ ] **8.2.4.1**: Configure GitHub OAuth application and add credentials to Supabase.
  - [ ] **8.2.4.2**: Configure Google OAuth application and add credentials to Supabase.
  - [ ] **8.2.4.3**: (Optional) Add additional social providers as needed.
- [ ] **8.2.5**: Implement the **Social Login Buttons Component**:
  - [ ] **8.2.5.1**: GitHub login button with appropriate icon.
  - [ ] **8.2.5.2**: Google login button with appropriate icon.
  - [ ] **8.2.5.3**: (Optional) Additional social login buttons.
- [ ] **8.2.6**: Create a Storybook story for the **Social Login Buttons Component**.
- [ ] **8.2.7**: Implement the **Auth Page Layout Component** that includes both Magic Link and Social Login options.
- [ ] **8.2.8**: Implement a **Role Selection Component** for new users to choose between job-seeker and recruiter after initial sign-in.
- [ ] **8.2.9**: Create a Storybook story for the **Role Selection Component**.
- [ ] **8.2.10**: Implement the **Auth Callback Handler** to process authentication redirects from Supabase:
  - [ ] **8.2.10.1**: Create a callback route to handle code exchange.
  - [ ] **8.2.10.2**: Implement session storage and redirection logic.
- [ ] **8.2.11**: Implement the **Sign Out Component** with confirmation action.
- [ ] **8.2.12**: Create a Storybook story for the **Sign Out Component**.
- [ ] **8.2.13**: Implement front-end logic for auth state management:
  - [ ] **8.2.13.1**: Create auth context provider to manage and share auth state.
  - [ ] **8.2.13.2**: Implement protected routes that require authentication.
- [ ] **8.2.14**: Ensure all auth components have proper accessibility considerations (aria labels, focus management, etc.).
- [ ] **8.2.15**: Write front-end tests for the auth components and flows.

### 8.3 Profile & CV Pages Components
- [ ] **8.3.1**: Design the **Profile Page** layout: divided into sections like "Personal Info", "CV/Resume", "Analytics", etc.
- [ ] **8.3.2**: Implement a **Profile Info Display Component** that shows a user's name, photo, bio, location, etc.
- [ ] **8.3.3**: Implement an **Edit Profile Form Component** (could be in a modal or separate page):
  - [ ] **8.3.3.1**: Fields for each editable profile item (name, location, bio, etc., possibly reuse input components).
  - [ ] **8.3.3.2**: A file input for profile photo.
  - [ ] **8.3.3.3**: Save button to submit changes.
- [ ] **8.3.4**: Create Storybook stories for **Profile Info Component** (view mode with sample data) and for **Edit Profile Form** (edit mode).
- [ ] **8.3.5**: Implement the **CV Upload Section** on the profile page:
  - A component that shows current CV status (e.g. "No CV uploaded" or "CV uploaded on DATE, last processed on DATE").
  - Upload button to add/replace CV.
  - If CV is uploaded and processed, maybe a button to view the anonymized CV or download original, and a button to delete it.
- [ ] **8.3.6**: Implement the **CV Upload Component** (internal to above section or standalone if reused):
  - Could reuse a generic FileUpload component.
  - Show file name selected and a progress bar or spinner when uploading.
  - Show success or error message after attempt.
- [ ] **8.3.7**: Create Storybook story for **CV Upload Component** (demonstrate idle state, file selected state, uploading state).
- [ ] **8.3.8**: Implement the **CV Analysis Summary Component**:
  - Display key info extracted (skills, experience summary) in a nice format (list of skill chips, paragraphs, etc.).
  - Show a notice that personal details have been removed for privacy.
- [ ] **8.3.9**: Create a Storybook story for **CV Analysis Summary** with example data (e.g. a few sample skills and a summary paragraph).
- [ ] **8.3.10**: Implement the **CV Analytics Component** (from 2.3.5):
  - Show number of views, contact requests in a styled box or chart.
  - Possibly a small chart or just text stats.
- [ ] **8.3.11**: Storybook story for **CV Analytics Component** with dummy numbers.
- [ ] **8.3.12**: Integrate all these components into the Profile page:
  - Top: Profile Info (with Edit button that toggles Edit Profile Form).
  - Middle: CV Upload & Summary section (shows upload or analysis results).
  - Bottom: CV Analytics (if any data).
  - Ensure the page fetches necessary data from APIs on load (profile info, CV status, analysis results, analytics).
- [ ] **8.3.13**: Ensure responsive design for profile page components (stack vertically on mobile, etc.).
- [ ] **8.3.14**: Test the profile page manually in the browser to verify all pieces work together (upload a CV and see it update, edit profile changes reflect, etc.).

### 8.4 Job Listings Pages & Components
- [ ] **8.4.1**: Design the **Job List Page** layout: include a search bar/filters section at top or side and a list of job result cards.
- [ ] **8.4.2**: Implement the **Job Search Bar/Filters Component**:
  - Fields: keyword text input, location input (could be text or a select list of cities), possibly dropdowns for other filters (job type, etc.).
  - Search/Filter button to trigger search.
  - Storybook story for this component with various filter fields.
- [ ] **8.4.3**: Implement the **Job Card Component** for displaying a job in the list:
  - Shows job title, company name, location, maybe a snippet of description, and posting date.
  - If the job is saved or applied (if we track that), indicate it (e.g. filled star icon if saved).
  - A "Save" button or icon to toggle save status.
  - Possibly an "Apply" or "Details" button.
- [ ] **8.4.4**: Create a Storybook story for **Job Card Component** (with example job data, and maybe variations: default vs saved state).
- [ ] **8.4.5**: Implement the **Job List Component** that takes an array of jobs and renders a list of Job Cards (with maybe lazy loading or pagination controls).
- [ ] **8.4.6**: Storybook story for **Job List Component** with a sample list of jobs (to see how it scrolls or paginates).
- [ ] **8.4.7**: Implement the **Job Details Page**:
  - Use components to display full job info: perhaps a **Job Description component** (to show the job description text formatted) and a **Company Info component** (logo and about company).
  - An "Apply Now" button that either links out (for external jobs) or triggers an in-platform apply (not in scope now, so likely just a link).
  - If linking out, ensure it opens in new tab.
- [ ] **8.4.8**: Storybook story for **Job Details components** (e.g. Job Description component with sample text, Company Info component with sample data).
- [ ] **8.4.9**: Integrate the search/filter logic:
  - When the Job List Page loads, fetch initial jobs (maybe trending or recent).
  - When the user enters a query or changes filters, call the API and update the list.
  - Show a loading indicator while fetching.
  - Handle no results scenario (show a "no jobs found" message).
- [ ] **8.4.10**: Implement pagination or infinite scroll for job results:
  - Either a "Load more" button at bottom or automatic load on scroll.
  - Make sure the API is called with proper page parameters.
  - One-story-point for basic "Load more" button implementation.
- [ ] **8.4.11**: Implement the **Saved Jobs Page**:
  - Show a list of jobs the user saved (reuse Job List/Job Card components).
  - Indicate if any saved job is no longer active (if we know, or allow them to remove).
- [ ] **8.4.12**: Add a toggle or icon on Job Card to save/unsave:
  - On click, call save API and update UI (optimistically update card state to saved).
  - If on saved jobs page, allow unsaving (remove from list on success).
- [ ] **8.4.13**: Implement the **Recommended Jobs Page/Section**:
  - If a separate page, similar to saved jobs but populated by match algorithm.
  - Or on the user home page, display a few recommended job cards.
  - Ensure it uses the data from the matching endpoint (section 7.2 integration).
- [ ] **8.4.14**: Ensure all job components are mobile-friendly (cards stack, filters become a collapsible panel on small screens, etc.).
- [ ] **8.4.15**: Write front-end tests for job search components: e.g. search bar input updates state, clicking search triggers API call (can mock), etc. (This might be done in the Testing section but noted here for completeness.)

### 8.5 Messaging & Notification Components
- [ ] **8.5.1**: Implement the **Contact Request Modal/Form Component** for recruiters (used when clicking "Contact Candidate"):
  - Fields: optional message textarea.
  - Send button.
  - Show loading state while sending, and success or error message.
  - Storybook story for this modal form.
- [ ] **8.5.2**: Implement the **Contact Requests List Component** for candidates:
  - Each item displays requester name, company, message snippet, and accept/decline buttons.
  - Could reuse a generic **User/Recruiter Card** component for consistency (with name, company, maybe logo).
  - Storybook story for a list with a couple of request items.
- [ ] **8.5.3**: Implement the **Message/Chat Component** (if in-app messaging):
  - Display a scrollable list of messages (maybe a **Message Bubble** sub-component for each message, styled differently for sent vs received).
  - Input box to type new message and send button.
  - Storybook story for Message Bubble (sent and received variants), and the Chat component with a sample conversation.
- [ ] **8.5.4**: Integrate the chat component into a **Messages Page** or modal:
  - If multiple conversations are supported, have a list of conversations (likely not since contact is one-to-one initiated via request).
  - If only one conversation per accepted request, you might go directly into that thread from the request list.
  - Ensure the chat updates when a new message is sent or received (could poll for new messages every few seconds or use WebSocket).
- [ ] **8.5.5**: Implement the **Notifications Dropdown Component** in the nav bar:
  - Icon (bell) with badge showing count of unread notifications.
  - Clicking shows a dropdown list of recent notifications (each with text like "Recruiter X sent you a contact request" etc.).
  - Each item clickable to navigate to the relevant page (requests page, messages, job, etc.).
  - Storybook story for Notifications dropdown with sample notifications.
- [ ] **8.5.6**: Implement a **Notifications Page** (or extend the dropdown to a larger panel) to show all notifications:
  - Mark all as read button.
  - Possibly group by date.
  - Use the Notification model data to render messages.
- [ ] **8.5.7**: Ensure real-time behavior:
  - When a new notification is received (perhaps simulate via storybook or test mode), the notification count updates.
  - Possibly use a global state or context to manage notifications list.
- [ ] **8.5.8**: Test the messaging UI manually:
  - Simulate an accepted contact and ensure the messaging page loads with correct data.
  - Send a message and see it appear (you might have to simulate the other user response or just ensure your message shows).
- [ ] **8.5.9**: Test the notification UI:
  - Create a scenario with multiple notifications (contact requests, message received, etc.) and ensure they display correctly and link to the right places.
- [ ] **8.5.10**: Write front-end tests for notifications component (e.g. ensuring that clicking the bell toggles the list, notification item calls mark-as-read, etc.) and for the contact request form (filling message and pressing send calls API).

### 8.6 Subscription & Payment UI Components
- [ ] **8.6.1**: Implement the **Pricing/Subscription Page** on the front-end:
  - Show available plans (Free vs Premium) with a comparison of features in a clear format.
  - Each plan has a "Select" or "Upgrade" button.
  - If using monthly/yearly options, allow toggle to display prices accordingly.
- [ ] **8.6.2**: Implement a **Plan Card Component** for each subscription plan:
  - Displays plan name, price, list of benefits.
  - Highlight the current plan for the user (if viewing while logged in and already subscribed).
  - Storybook story for Plan Card (one for Free, one for Premium).
- [ ] **8.6.3**: On the Pricing page, if the user is not logged in and is a recruiter wanting to subscribe, prompt login or registration first when clicking upgrade.
- [ ] **8.6.4**: If the user is a recruiter on Free plan:
  - Show an **Upgrade Call-to-Action** component in places like the contact request modal or candidate search page when they reach a limit (like "Upgrade to Premium to contact more candidates").
  - Storybook story for an Upgrade CTA banner/modal.
- [ ] **8.6.5**: After the user selects a plan, implement the **Checkout Process UI**:
  - A loading state or redirect notice while creating the Stripe Checkout session.
  - Possibly a confirmation modal that will redirect them.
  - Handle the redirection to Stripe (this might just be a JS call, not a visible component, but ensure feedback).
- [ ] **8.6.6**: Implement the **Post-Checkout Pages**:
  - A "Payment Success" page: thank you message, summary of their plan, maybe next steps (like "You can now send unlimited requests").
  - A "Payment Canceled" page: allow them to retry or contact support.
- [ ] **8.6.7**: Implement an **Account/Billing Settings Page** for the user:
  - Show current plan and renewal date.
  - If premium, show a "Manage Subscription" button that leads to Stripe Customer Portal or triggers cancel process.
  - If free, show an upgrade button.
- [ ] **8.6.8**: Ensure to handle states:
  - If a subscription is in process (payment initiated but not confirmed), maybe disable multiple clicks or indicate pending.
  - If subscription expired, reflect that in UI and revert to free features.
- [ ] **8.6.9**: Storybook stories for **Account/Billing Info component** with different states (Free vs Premium user).
- [ ] **8.6.10**: Test subscription UI flows:
  - Start from a free recruiter, go to pricing, click upgrade (should redirect to Stripe, which we simulate by skipping actual payment in test).
  - After "payment", manually set user as premium in dev, then see that account page shows Premium.
  - Test cancel subscription flow (maybe simulate via webhook or change in DB, then reload account page to see it offering re-subscribe).
- [ ] **8.6.11**: Ensure all payment-related UI is mobile friendly and clearly communicates any errors from Stripe (like declined card via an error page, though Stripe checkout usually handles card input errors on their side).

### 8.7 Admin Panel UI Components
- [ ] **8.7.1**: Implement the **Admin Dashboard Page UI**:
  - Use a simple grid or cards to display key metrics (user count, etc. from section 6.2).
  - Provide navigation buttons or links to sub-pages (Users, Jobs, Reports, etc.).
- [ ] **8.7.2**: Implement the **User Management Table Component**:
  - Table or list view of users with columns: Name, Email, Role, Status, Actions (edit/ban).
  - Possibly use a data table library or simple table with pagination controls.
  - Storybook story with sample user data list.
- [ ] **8.7.3**: Implement **User Action Buttons** in each row (e.g. "Ban/Unban", "Promote to Admin/Recruiter"):
  - These trigger modals or confirmations (especially for ban).
  - Ensure admin cannot ban themselves inadvertently.
  - Storybook story for a row with actions (not interactive in story, just showing buttons).
- [ ] **8.7.4**: Implement the **Job Listings Admin Table**:
  - Similar to user table: columns for job title, company, source, date, and an action to remove/hide.
  - Storybook story with sample jobs.
- [ ] **8.7.5**: Implement the **Reports List Component** (if reports system added):
  - List of reports with reporter, subject, reason, status, and action buttons (like "View & Resolve").
  - Could reuse some user profile mini-view for the subject of report.
- [ ] **8.7.6**: Implement an **Admin Modal or Detail View** for a single report or user:
  - E.g. clicking on a report opens details (full report description and options to ban user or dismiss report).
  - Clicking on a user could open a detail panel with their profile info and an option to impersonate or view as user (if we choose to have that feature).
- [ ] **8.7.7**: Implement the **Admin Analytics Charts**:
  - Use a chart library or simple SVG for one or two key charts (e.g. user signups over last 30 days).
  - Storybook story with a dummy chart (if possible, or just ensure the component renders static data in story).
- [ ] **8.7.8**: Ensure the admin UI is clearly distinct (maybe a different color scheme or "Admin" label) so admins know they are in admin mode and normal users never see it.
- [ ] **8.7.9**: Secure the front-end routes for admin:
  - If a non-admin somehow tries to access `/admin` route, the front-end should redirect them or show a "Not authorized" message (in addition to backend protection).
  - Implement a Not Authorized page or redirect to home for such cases.
- [ ] **8.7.10**: Test the admin UI:
  - As an admin user, navigate to each section, verify data loads (use test data), perform actions (ban a user, etc.) and see that UI updates (e.g. user marked banned).
  - Ensure nothing leaks to non-admin (log in as normal user and confirm no admin links or access).
- [ ] **8.7.11**: Write front-end tests for admin components (if feasible, e.g. simulate rendering the user table and clicking an action, mock API response and verify state change).

## 9. Testing Plan

### 9.1 Unit Testing
- [ ] **9.1.1**: Set up the unit testing framework for backend (e.g. Jest for Node, or PyTest for Python, etc. depending on stack). Configure test environment (separate test database or in-memory DB).
- [ ] **9.1.2**: Write unit tests for **utility functions** (e.g. password hashing verification, text extraction from CV, anonymization regex function, match score calculation).
- [ ] **9.1.3**: Write unit tests for **validation logic** in registration and profile updates (e.g. invalid email rejection, password strength enforcement).
- [ ] **9.1.4**: Write unit tests for **contact request logic** (e.g. a function that checks if a request can be sent given subscription and privacy settings).
- [ ] **9.1.5**: Write unit tests for **notification formatting** (e.g. given an event, does the system create the correct notification message and type).
- [ ] **9.1.6**: Write unit tests for **subscription utilities** (e.g. function that calculates remaining quota of contact requests, or next billing date calculations if any).
- [ ] **9.1.7**: Write unit tests for **AI integration functions** with mocks:
  - Test that the prompt assembly function includes all necessary parts of the text.
  - Mock the OpenAI API response to test parsing logic (e.g. if OpenAI returns a known JSON, our code properly extracts fields).
- [ ] **9.1.8**: Write unit tests for **job matching score function** (feed in known data and verify the score or ranking outcome).
- [ ] **9.1.9**: Write unit tests for front-end **pure functions or reducers** (if using Redux or similar for state management, test that reducers update state as expected).
- [ ] **9.1.10**: Write unit tests for front-end **components logic**:
  - If using React, use React Testing Library to test components in isolation (e.g. LoginForm calls onSubmit with correct data when filled, NotificationDropdown shows correct count).
  - Use shallow rendering or DOM testing to verify component renders given props.
- [ ] **9.1.11**: Aim for a high coverage on critical modules: ensure that core business logic paths (auth, CV processing, contact request handling) are covered by unit tests.
- [ ] **9.1.12**: Configure code coverage reporting and ensure the CI pipeline displays coverage results to catch untested code.

### 9.2 Integration Testing
- [ ] **9.2.1**: Set up integration testing environment for the backend API (possible tools: use Jest with Supertest for Node, or use a separate testing tool that can call HTTP endpoints).
- [ ] **9.2.2**: Write integration tests for **Auth flows**:
  - Register a new user via API, simulate clicking verification (maybe directly call verify endpoint), then attempt login, assert successful auth token response.
  - Test login with wrong password returns error.
  - Test password reset flow: request reset, retrieve token from DB or mock, reset password, then login with new password.
- [ ] **9.2.3**: Write integration tests for **Profile and CV flows**:
  - After registering, call profile update API to add details, verify data is saved.
  - Upload a dummy CV file (possibly a small text PDF) via the API, then poll or wait for processing, then fetch the CV data and verify it has anonymized text.
  - Try to fetch another user's profile as a different user (should be forbidden if that API is protected).
- [ ] **9.2.4**: Write integration tests for **Job search API**:
  - Insert some job entries in test DB (or use a known seed).
  - Call search with a keyword, verify the returned jobs match the query.
  - Test filter combinations (e.g. location filter).
- [ ] **9.2.5**: Write integration tests for **Contact Request workflow**:
  - Create a recruiter user with an active subscription (you might bypass Stripe by setting the flag in DB in test).
  - Create a candidate user with CV uploaded and privacy opt-in.
  - As recruiter, call send contact request API, verify pending request in DB.
  - As candidate, call respond (accept) API, verify request status updated and maybe that a message thread or contact info exchange took place.
- [ ] **9.2.6**: Write integration tests for **Notifications**:
  - Trigger events (like contact request sent, accepted) within test, then call notifications API to ensure the correct notifications exist.
  - Mark one as read via API and ensure it no longer shows as unread.
- [ ] **9.2.7**: Write integration tests for **Subscription and Stripe**:
  - This is tricky due to external calls; possibly simulate by calling our checkout endpoint (which returns a session URL) and then simulate a webhook call for subscription creation.
  - Verify that after webhook processing, the user's subscription status is updated.
  - Test that a user without subscription cannot send contact (should get 402 or 403 error).
- [ ] **9.2.8**: Write integration tests for **Admin APIs**:
  - Call the user listing API as admin, verify data; as normal user, verify access denied.
  - Change a user's role via admin API and verify effect (e.g. user now has recruiter access).
  - Test an admin deleting a job or banning a user and ensure the data changes (job marked removed, user flagged banned).
- [ ] **9.2.9**: Ensure tests clean up after themselves:
  - Use transactions or fresh test database that resets between tests to avoid data leakage affecting other tests.
  - Or use fixtures and tear down properly.
- [ ] **9.2.10**: Run the full integration test suite and ensure it passes consistently before merging new changes (incorporate into CI).

### 9.3 End-to-End (E2E) Testing
- [ ] **9.3.1**: Choose an E2E testing framework (e.g. Cypress for web UI). Set up the test runner and configure base URL, etc.
- [ ] **9.3.2**: Write E2E test for **Job-seeker Sign Up and Profile Completion**:
  - Simulate user visiting the registration page, filling details, submitting.
  - (Optionally simulate email verification by calling backend directly or by exposing a test-only flag to auto-verify in dev).
  - After registration, log in with those credentials.
  - Fill out additional profile info on profile page, upload a test CV file.
  - Wait for or simulate CV processing complete (maybe stub the API to return a prepared analysis for test).
  - Verify that recommended jobs section shows up (if any) or that profile info is displayed correctly.
- [ ] **9.3.3**: Write E2E test for **Job Search and Save**:
  - Simulate user logging in, going to job search page.
  - Enter a query in the search bar, verify that results appear.
  - Click on a job to view details, then click save on that job.
  - Go to saved jobs page and verify the job is listed.
- [ ] **9.3.4**: Write E2E test for **Recruiter Subscription and Contact**:
  - Simulate recruiter registering (or have a test user flagged as recruiter).
  - Navigate to subscription page, choose a plan.
  - Instead of actually going to Stripe (which is not feasible in test), you might stub the checkout process by directly updating the user to premium in the test or using Stripe test mode with a known outcome.
  - After "upgrading", go to candidate search page, search for a skill.
  - Click on a candidate result, send a contact request via the form.
  - Log out, log in as the candidate test account, go to requests page, accept the request.
  - If messaging is on, send a message and verify recruiter sees it (this might be complicated to automate both sides in one test, might do sequentially logging as each).
- [ ] **9.3.5**: Write E2E test for **Notifications flow**:
  - (Using the scenario above) After contact request is sent, as candidate check that a notification badge is present.
  - After acceptance, as recruiter check a notification is shown.
  - Click the notification and verify it navigates to the appropriate page (messages or contact info).
- [ ] **9.3.6**: Write E2E test for **Admin usage**:
  - Log in as admin user.
  - Go to admin panel, verify user list loads.
  - Ban a user through UI, then log out and try to log in as that banned user (should fail).
  - Possibly test unbanning if needed.
  - Check that admin analytics page shows expected data (if test can create some users or jobs and then see counts).
- [ ] **9.3.7**: Incorporate E2E tests into CI (if using Cypress, set it up with headless mode). Ensure tests run on a clean test environment (maybe spin up the app and a test database).
- [ ] **9.3.8**: Ensure E2E tests isolate or reset data:
  - Possibly use a separate testing database or create/destroy needed data via API calls in the test setup/teardown.
  - Avoid E2E tests depending on each other; each test should set up its required state (e.g. create its own user).
- [ ] **9.3.9**: Monitor E2E test run time and optimize if needed (maybe skip some steps or combine flows to reduce total time, as long as clarity is maintained).
- [ ] **9.3.10**: Document how to run the E2E tests for developers and what scenarios are covered, so future tests can be added for new features.

### 9.4 Accessibility Testing
- [ ] **9.4.1**: Perform an **accessibility audit** of the application using tools like Lighthouse or axe-core:
  - Run Lighthouse on key pages (login, profile, job search, etc.) and note accessibility scores and issues.
  - Use axe (via browser extension or in automated tests) to identify specific violations (missing alt text, low contrast, etc.).
- [ ] **9.4.2**: Fix all images missing alt attributes:
  - Ensure the profile photo, company logos, etc. have meaningful alt text (or blank alt if purely decorative).
  - Update any icon-only buttons (like the notification bell, hamburger menu) with appropriate `aria-label` or screen-reader text.
- [ ] **9.4.3**: Ensure form elements are properly labeled:
  - All input fields should have `<label>` tags or aria-labels. Link form errors to fields via `aria-describedby`.
  - The login and registration forms especially should be checked for screen reader navigation.
- [ ] **9.4.4**: Check keyboard navigation:
  - All interactive elements (links, buttons, form inputs) should be reachable via Tab navigation in a logical order.
  - Modals (like contact request form) should trap focus when open and return focus on close.
  - Implement fixes for any elements that are not accessible via keyboard (e.g. custom dropdowns need arrow key support or so).
- [ ] **9.4.5**: Ensure color contrast meets WCAG AA:
  - Check text vs background contrast for all components (e.g. text over banners, button text on background).
  - Adjust CSS with darker text or lighter background as needed to improve contrast.
- [ ] **9.4.6**: Add ARIA roles and attributes where appropriate:
  - Mark navigation menus with `nav` role.
  - Use ARIA live regions for dynamic updates like notification counts or error messages so screen readers announce them.
  - Ensure the job list is marked up in a meaningful way (maybe list with listitems).
- [ ] **9.4.7**: Test with a screen reader (NVDA/VoiceOver) basic flows:
  - Verify that logging in, navigating to profile, and using job search can be done with announcements making sense (e.g., when a new page loads, the title is announced).
  - Ensure dynamic content (like appearing notifications or chat messages) is announced or can be found by the screen reader user.
- [ ] **9.4.8**: Create an accessibility test suite (optional):
  - Use axe-core integration in automated tests to run on each page and fail the test if critical accessibility issues exist.
  - At minimum, run this on main page templates (login, dashboard, profile, etc.).
- [ ] **9.4.9**: Document any remaining accessibility issues that cannot be fixed immediately (maybe none if all addressed) and plan to handle them.
- [ ] **9.4.10**: Ensure accessibility is part of the definition of done for future tasks (not a one-time thing) – include a note in project guidelines (not a coding task per se, but important for completeness).

### 9.5 Performance Testing
- [ ] **9.5.1**: Conduct a **performance audit** on critical user flows:
  - Measure page load times for main pages (especially job list page which could load many items).
  - Measure API response times for key endpoints (auth, job search, etc.).
  - Identify any slow queries or functions via profiling (for example, analyze if job matching or scraping could be slow).
- [ ] **9.5.2**: Load test the job search API with a tool (e.g. JMeter, Artillery):
  - Simulate a high number of concurrent search requests to ensure the system and database can handle it.
  - If performance degrades significantly, consider adding caching or optimizing query (one-story improvement if needed).
- [ ] **9.5.3**: Load test the contact request flow under concurrency:
  - Simulate multiple recruiters sending requests at the same time and ensure no deadlocks or race issues (especially if counting usage).
  - Ensure the notification system can handle bursts (maybe use a queue for sending emails to not block processes).
- [ ] **9.5.4**: Profile the CV processing pipeline:
  - If multiple CVs are uploaded at once, does the OCR/AI queue up properly and complete within acceptable time?
  - Determine max throughput (CVs per minute) and if needed, consider scaling strategies (like can process jobs run in parallel or need sequential due to API limits).
- [ ] **9.5.5**: Assess front-end performance for large data:
  - e.g. If job list has 100+ results, does the rendering lag? Consider using windowing (like react-window) if needed for very long lists (one-story if needed).
  - Ensure that heavy components (like chart libraries or rich text) only load when needed (code-splitting if using SPA).
- [ ] **9.5.6**: Optimize assets and bundles:
  - Check the bundle size of the front-end app. Remove unused libraries, enable tree shaking/production minification.
  - Use lazy loading for large modules (perhaps admin panel loads separately).
  - Verify images (like logos) are optimized or use CDN if applicable.
- [ ] **9.5.7**: Implement basic server-side caching for frequent requests:
  - Possibly cache job search results for popular queries for a short time.
  - Cache static content responses (like the landing page) if any.
  - Use HTTP caching headers where appropriate (one-story to set up for static files or API GET responses that can be cached).
- [ ] **9.5.8**: Monitor memory and CPU usage during tests:
  - Identify any memory leaks in the app (for example, unclosed database connections or accumulative arrays).
  - Fix any such issues (one-story per issue found).
- [ ] **9.5.9**: Test the application in a production-like environment:
  - If possible, deploy to a staging server and run performance tests from an external machine to simulate real network conditions.
  - Check that the system meets performance targets (e.g. < X seconds page load on average, Y req/sec API throughput).
- [ ] **9.5.10**: Set up performance monitoring for production (this crosses into monitoring section):
  - Integrate an APM (Application Performance Monitoring) tool (like New Relic, Datadog, etc.) to track response times and resource usage over time.
  - This is a one-story task if decided, ensuring the agent is installed and key transactions are traced.
- [ ] **9.5.11**: Based on testing results, create optimization tasks for any bottlenecks found (for example, if scraping is slow, consider parallelizing it; if matching is slow, consider better algorithms or indexing).

## 10. Deployment & Monitoring

### 10.1 CI/CD Pipeline
- [ ] **10.1.1**: Set up a Git repository for the project and define branching strategy (e.g. main for production, develop for integration, feature branches, etc.).
- [ ] **10.1.2**: Configure a **CI pipeline** (using GitHub Actions, GitLab CI, Jenkins, etc.):
  - Include steps to install dependencies, run unit and integration tests, and build the application (both backend and frontend).
  - Set up environment variables for CI (like test database credentials, etc.) securely.
- [ ] **10.1.3**: Integrate automated tests into the CI: ensure that on each push or merge request, the test suite runs and fails the build if any test fails.
- [ ] **10.1.4**: Add a step in CI for linting/static analysis (e.g. ESLint for JS, flake8 for Python, etc.) to maintain code quality.
- [ ] **10.1.5**: Configure **CD (Continuous Deployment)** for at least a staging environment:
  - After tests pass on the main branch, automatically deploy to a staging server/environment.
  - This could involve building a Docker image and pushing to a registry, or directly rsyncing files to a server, depending on infrastructure.
- [ ] **10.1.6**: Prepare the production deployment process:
  - Possibly set up infrastructure (e.g. an AWS EC2 or Heroku/DigitalOcean instance, or a Kubernetes cluster if using containers).
  - Create deployment scripts or use CI to deploy to production when code is tagged or manually triggered.
- [ ] **10.1.7**: Set up the database in production (and staging):
  - Ensure running migrations is part of the deployment process (to apply new schema changes).
  - Secure database credentials via environment variables.
- [ ] **10.1.8**: Configure environment-specific settings:
  - For example, use Stripe test keys in staging and live keys in production (ensure they are not mixed up).
  - Set DEBUG mode off in production.
  - Set appropriate domain names or callback URLs for OAuth (if any) and Stripe webhook URLs.
- [ ] **10.1.9**: Implement a smoke test after deployment:
  - Have the CI run a simple check (like call the health-check endpoint of the deployed app, or run a few critical flows in staging) to ensure the deploy was successful.
  - Notify the team (maybe via Slack/email) on deploy success or failure.
- [ ] **10.1.10**: Ensure rollback strategy:
  - Keep previous build artifacts or Docker images so if a deployment fails or causes issues, you can quickly roll back to last known good version.
  - Document the rollback steps (one-story to test a rollback manually).
- [ ] **10.1.11**: Test the CI/CD pipeline by making a small change and verifying it goes through build, test, and deploy steps correctly.
- [ ] **10.1.12**: Implement versioning of the application (even simple, like using commit hash or semantic version in the footer or logs) to identify which version is running where.

### 10.2 Monitoring & Maintenance
- [ ] **10.2.1**: Set up **Application Logging**:
  - Use a structured logging library in the backend to output logs (with timestamps, log levels, request IDs).
  - Ensure logs include important events (e.g. errors, major actions like user login success/failure, etc. but avoid sensitive info).
- [ ] **10.2.2**: Choose a logging/monitoring service:
  - e.g. integrate with a service like Sentry for error tracking, or use a cloud logging service (AWS CloudWatch, ELK stack) to aggregate logs.
  - One-story to add Sentry SDK to frontend and backend to capture exceptions and send to the dashboard.
- [ ] **10.2.3**: Implement **Error Notification**:
  - Configure Sentry (or chosen service) to alert (email/Slack) when a new error occurs in production above a threshold.
  - Ensure uncaught exceptions in backend automatically get logged and reported.
  - For front-end, capture console errors and send to Sentry as well.
- [ ] **10.2.4**: Set up **Health Check endpoints** for the app:
  - A simple endpoint (e.g. `/healthz`) that returns OK if the app and database are reachable. Use this for monitoring uptime.
  - If using load balancers, they can ping this endpoint.
- [x] **10.2.5**: Set up an **Uptime Monitoring** service (Pingdom, UptimeRobot, etc.):
  - Monitor the public endpoints (maybe homepage) to alert if the site is down.
  - One-story to configure a free uptime monitor to ping the site every few minutes.
- [ ] **10.2.6**: Schedule **Database Backups**:
  - If using a managed DB, ensure automated backups are enabled.
  - If self-hosted, set up a cron job or service to dump the database daily and securely store the backup (encrypt and upload to cloud storage).
  - Verify backups by occasionally restoring them to a dev environment to ensure they work.
- [ ] **10.2.7**: Backup user-uploaded files (CVs, profile images):
  - If stored on cloud (S3), enable bucket versioning or periodic sync to another bucket.
  - If on server, include them in backup script or mount a network drive with redundancy.
- [x] **10.2.8**: Monitor **Performance in production**:
  - Use the APM set up (if any) or at least log slow requests (e.g. any API call taking > X seconds logs a warning).
  - Keep an eye on memory/CPU on the server (set up alerts if CPU > 80% for 5 minutes, etc.).
- [ ] **10.2.9**: Set up a basic **Analytics dashboard** for business (outside admin metrics):
  - Perhaps integrate Google Analytics on the front-end to track page views, or simple custom tracking for key actions, to understand user behavior.
  - Not critical for functionality, but helpful for monitoring usage.
- [ ] **10.2.10**: Ensure **Security Monitoring**:
  - Keep dependencies up to date (one-story: add a Dependabot or similar in GitHub to alert for vulnerabilities).
  - Regularly review server security (close unnecessary ports, use HTTPS, rotate secrets if needed).
  - Add tasks for any vulnerability fixes that come up.
- [x] **10.2.11**: Establish a **Disaster Recovery Plan**:
  - Document how to restore service from backups if the database or server is lost.
  - One small task to simulate a recovery: take a backup and restore it to a new instance in staging to measure the time and steps needed.
- [x] **10.2.12**: Set up continuous **Monitoring of third-party services**:
  - For Stripe, ensure webhooks are monitored (log if any fail, and have a way to replay).
  - For the AI API, monitor usage and set alerts if approaching any quotas or spending limits.
- [x] **10.2.13**: Regular Maintenance tasks:
  - Cleanup old data: e.g. remove or archive job listings that are older than X months to keep DB lean.
  - Rotate logs or archive logs to avoid disk fill-up.
  - These can be scheduled cron jobs or periodic manual tasks listed in admin panel if needed.
